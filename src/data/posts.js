export const mockPosts = [
  {
    id: 1,
    title: "Getting Started with React",
    slug: "getting-started-with-react",
    excerpt: "Learn the basics of React, including components, JSX, and props.",
    content:
      "React is a JavaScript library for building user interfaces. It allows developers to create reusable components that update efficiently when data changes. At its core, React encourages building UIs using a declarative style, making code more predictable and easier to debug. With JSX, you can write HTML-like syntax inside JavaScript, which improves readability. Props allow you to pass data into components, making them dynamic. Learning React is a great first step for front-end development, and once you master it, you'll be ready to explore advanced tools like Redux, React Router, and server-side rendering with Next.js.",
    image: "https://picsum.photos/400/250?random=1",
    date: "2025-08-10",
    author: "Admin",
  },
  {
    id: 2,
    title: "Understanding Redux Toolkit",
    slug: "understanding-redux-toolkit",
    excerpt: "A complete guide to managing global state with Redux Toolkit.",
    content:
      "Redux Toolkit is the recommended way to write Redux logic today. It simplifies many of the common patterns and removes boilerplate, which used to make Redux feel intimidating. With features like createSlice, configureStore, and createAsyncThunk, developers can quickly set up state management without unnecessary complexity. Redux Toolkit also comes with built-in support for middleware, making async requests more manageable. Whether you're managing authentication, API data, or UI state, Redux Toolkit provides a structured and scalable solution. Once you integrate it with React, you'll find state management much cleaner and more intuitive.",
    image: "https://picsum.photos/400/250?random=2",
    date: "2025-08-12",
    author: "Admin",
  },
  {
    id: 3,
    title: "TailwindCSS Tips & Tricks",
    slug: "tailwindcss-tips-tricks",
    excerpt: "Boost your UI development with these TailwindCSS shortcuts.",
    content:
      "TailwindCSS is a utility-first CSS framework that allows developers to style applications rapidly using pre-defined utility classes. Instead of writing custom CSS for each component, you can use combinations of classes like flex, justify-center, text-gray-700, or bg-blue-500 to style directly in your JSX. Tailwind also provides responsive design utilities, enabling you to quickly adapt layouts across screen sizes. Features like dark mode, hover states, and custom themes are built right in. By learning how to compose utilities effectively, you can drastically speed up your workflow. TailwindCSS also pairs well with component libraries like Headless UI for complete design systems.",
    image: "https://picsum.photos/400/250?random=3",
    date: "2025-08-14",
    author: "Admin",
  },
  {
    id: 4,
    title: "Mastering React Router v6",
    slug: "mastering-react-router-v6",
    excerpt: "Navigate like a pro with React Router v6.",
    content:
      "React Router v6 introduced several powerful updates that make routing in React applications simpler and more flexible. With features like nested routes, element-based routing, and hooks like useNavigate, you can build dynamic navigation systems with ease. The new outlet component allows better handling of nested UI layouts, and route protection has become more straightforward. React Router v6 also provides better lazy loading options, enabling faster performance by splitting your app into smaller bundles. Understanding these changes is critical for modern React developers, as almost every large-scale application requires smooth routing and navigation experiences for users.",
    image: "https://picsum.photos/400/250?random=4",
    date: "2025-08-15",
    author: "Admin",
  },
  {
    id: 5,
    title: "Next.js vs Create React App",
    slug: "nextjs-vs-create-react-app",
    excerpt: "Which one should you use for your next project?",
    content:
      "Next.js and Create React App (CRA) both provide ways to build React applications, but they cater to different use cases. CRA is great for beginners and small projects that only need client-side rendering. It's simple and has minimal configuration. On the other hand, Next.js offers server-side rendering (SSR), static site generation (SSG), API routes, and image optimization out of the box. This makes it ideal for SEO-friendly and production-grade applications. While CRA helps you get started quickly, Next.js prepares your project for scalability and performance. The choice often depends on your project's goals: speed of setup vs long-term flexibility.",
    image: "https://picsum.photos/400/250?random=5",
    date: "2025-08-16",
    author: "Admin",
  },
  {
    id: 6,
    title: "Building REST APIs with Node.js",
    slug: "building-rest-apis-with-nodejs",
    excerpt: "Learn to create robust REST APIs using Node.js and Express.",
    content:
      "Node.js, combined with Express, provides a lightweight and efficient way to build RESTful APIs. Express simplifies routing, middleware handling, and request/response processing, making API development fast and maintainable. By following REST principles, you can design endpoints that handle CRUD operations on resources like users, products, or blog posts. Adding middleware for authentication, error handling, and logging ensures a secure and reliable system. With Node.js' non-blocking I/O model, APIs can scale to handle thousands of concurrent requests. Understanding how to design and structure your REST API is essential for any full-stack developer working with modern web applications.",
    image: "https://picsum.photos/400/250?random=6",
    date: "2025-08-17",
    author: "Admin",
  },
  {
    id: 7,
    title: "MongoDB Best Practices",
    slug: "mongodb-best-practices",
    excerpt: "Optimize your MongoDB database for scalability and performance.",
    content:
      "MongoDB is a popular NoSQL database used in countless web applications. While it's easy to get started with, scaling and optimizing MongoDB requires following best practices. For example, using indexes correctly can drastically improve query performance. Structuring your documents to match application access patterns ensures efficiency. Avoiding unbounded arrays, splitting data into collections properly, and managing relationships with references or embedding are important design considerations. Additionally, MongoDB provides powerful aggregation pipelines for data transformation. Following these guidelines will help prevent bottlenecks and ensure your database remains performant even as your application grows.",
    image: "https://picsum.photos/400/250?random=7",
    date: "2025-08-18",
    author: "Admin",
  },
  {
    id: 8,
    title: "TypeScript for React Developers",
    slug: "typescript-for-react-developers",
    excerpt: "Add type safety to your React apps with TypeScript.",
    content:
      "TypeScript extends JavaScript by adding static typing, which allows developers to catch errors at compile time rather than runtime. For React developers, this means defining prop types, state, and hooks with strong type definitions, leading to more reliable code. TypeScript improves developer productivity by providing autocompletion and better IDE support. It also makes refactoring easier, since type errors reveal where changes are required. Many modern React projects now prefer TypeScript because of its maintainability in large codebases. By integrating TypeScript early, you can reduce bugs, improve collaboration, and make your applications more robust.",
    image: "https://picsum.photos/400/250?random=8",
    date: "2025-08-19",
    author: "Admin",
  },
  {
    id: 9,
    title: "Deploying React Apps on Vercel",
    slug: "deploying-react-apps-on-vercel",
    excerpt: "A step-by-step guide to hosting React projects on Vercel.",
    content:
      "Vercel has become one of the most popular platforms for deploying modern web apps. With zero-config deployment for React and Next.js projects, it allows developers to go live quickly. To deploy, you can simply connect your GitHub repository and let Vercel handle the build process. It automatically provides previews for pull requests, enabling collaborative review. Custom domains, HTTPS, and global CDN distribution are included out of the box. Vercel also supports environment variables and serverless functions, making it versatile for both frontend and backend needs. Learning to deploy on Vercel ensures that your projects can reach production with minimal effort.",
    image: "https://picsum.photos/400/250?random=9",
    date: "2025-08-20",
    author: "Admin",
  },
  {
    id: 10,
    title: "React Performance Optimization",
    slug: "react-performance-optimization",
    excerpt: "Improve the speed of your React apps with proven techniques.",
    content:
      "React applications can slow down if not optimized properly, especially as they grow in size. Performance optimization strategies include using React.memo to prevent unnecessary re-renders, leveraging useCallback and useMemo for expensive computations, and splitting code with dynamic imports. Virtualizing long lists with libraries like react-window can also reduce rendering overhead. Developers should avoid deeply nested state and excessive prop drilling, instead using context or state management libraries. Monitoring performance with tools like React DevTools and Chrome Performance panel helps identify bottlenecks. By applying these techniques, React apps can remain smooth and responsive at scale.",
    image: "https://picsum.photos/400/250?random=10",
    date: "2025-08-21",
    author: "Admin",
  },
  {
    id: 11,
    title: "GitHub Actions for CI/CD",
    slug: "github-actions-for-ci-cd",
    excerpt: "Automate testing and deployment pipelines using GitHub Actions.",
    content:
      "GitHub Actions enables developers to set up continuous integration and deployment pipelines directly within their repositories. You can configure workflows using YAML files that define when actions should trigger, such as on pull requests or pushes to the main branch. Common use cases include running automated tests, linting code, and deploying to environments like Vercel, Netlify, or AWS. GitHub Actions provides a marketplace of reusable actions, making it easy to integrate third-party tools. This automation not only reduces manual work but also ensures higher code quality and faster shipping. Mastering GitHub Actions is invaluable for modern DevOps practices.",
    image: "https://picsum.photos/400/250?random=11",
    date: "2025-08-22",
    author: "Admin",
  },
  {
    id: 12,
    title: "Docker for JavaScript Developers",
    slug: "docker-for-javascript-developers",
    excerpt:
      "Learn how to containerize your JavaScript applications with Docker.",
    content:
      "Docker allows developers to package applications and dependencies into portable containers, ensuring consistency across environments. For JavaScript developers, this means no more 'works on my machine' issues. By writing a Dockerfile, you can define the environment needed for your app, including Node.js, libraries, and system dependencies. Docker Compose lets you manage multi-container setups, such as a Node.js API with a MongoDB service. Containers also integrate seamlessly with cloud platforms, enabling scalable deployments. Understanding Docker is increasingly essential for full-stack developers, as it bridges development and operations, making applications more reliable in production.",
    image: "https://picsum.photos/400/250?random=12",
    date: "2025-08-23",
    author: "Admin",
  },
  {
    id: 13,
    title: "Introduction to GraphQL",
    slug: "introduction-to-graphql",
    excerpt: "Discover how GraphQL changes the way we fetch data.",
    content:
      "GraphQL is a query language for APIs that gives clients the power to ask for exactly the data they need. Unlike REST, where multiple endpoints may be required, GraphQL provides a single endpoint with flexible queries. This reduces over-fetching and under-fetching of data. Developers define a schema that describes available types and operations, making the API self-documenting. With resolvers, you connect schema fields to your backend logic. GraphQL also supports powerful features like mutations, subscriptions, and fragments. Many modern frameworks, such as Apollo and Relay, provide easy integration with React. GraphQL is transforming how teams build scalable APIs.",
    image: "https://picsum.photos/400/250?random=13",
    date: "2025-08-24",
    author: "Admin",
  },
  {
    id: 14,
    title: "Authentication with JWT",
    slug: "authentication-with-jwt",
    excerpt: "Secure your apps with JSON Web Token authentication.",
    content:
      "JSON Web Tokens (JWT) are a popular way to handle authentication in modern applications. A JWT consists of three parts: header, payload, and signature. After a user logs in, the server generates a JWT containing user information and signs it. The client stores this token (usually in localStorage or cookies) and includes it in future requests. The server verifies the token signature to authenticate the user. JWTs are compact, stateless, and widely supported across frameworks. Best practices include setting token expiration, refreshing tokens securely, and avoiding sensitive data in the payload. Proper JWT implementation ensures secure and scalable authentication.",
    image: "https://picsum.photos/400/250?random=14",
    date: "2025-08-25",
    author: "Admin",
  },
  {
    id: 15,
    title: "Responsive Design Principles",
    slug: "responsive-design-principles",
    excerpt: "Build websites that look great on all devices.",
    content:
      "Responsive design ensures that websites adapt gracefully to different screen sizes and devices. Techniques include using fluid grids, flexible images, and CSS media queries. Mobile-first design encourages developers to start with small screens and progressively enhance layouts for larger devices. Frameworks like TailwindCSS and Bootstrap make implementing responsiveness easier with pre-defined classes. Testing across devices and screen resolutions is critical to ensure usability. With the rise of mobile browsing, responsive design is no longer optional—it is essential for accessibility, user satisfaction, and SEO performance. A truly responsive site delivers a consistent experience everywhere.",
    image: "https://picsum.photos/400/250?random=15",
    date: "2025-08-26",
    author: "Admin",
  },
  {
    id: 16,
    title: "State Management with Context API",
    slug: "state-management-with-context-api",
    excerpt: "Leverage React's Context API for simple global state.",
    content:
      "The Context API provides a way to share state across React components without prop drilling. By creating a context provider, you can wrap parts of your app and pass down values directly to child components. This is especially useful for themes, authentication, or settings that are needed throughout the app. While Context is not a replacement for more advanced state management libraries, it works well for smaller or medium-sized applications. Combined with useReducer, you can achieve Redux-like patterns with less setup. Learning to balance when to use Context vs libraries like Redux is a valuable skill for React developers.",
    image: "https://picsum.photos/400/250?random=16",
    date: "2025-08-27",
    author: "Admin",
  },
  {
    id: 17,
    title: "Serverless Functions Explained",
    slug: "serverless-functions-explained",
    excerpt: "Understand serverless computing and how to use it.",
    content:
      "Serverless computing allows developers to focus on writing code without managing servers. With serverless functions, your code runs in isolated environments that scale automatically. Platforms like AWS Lambda, Vercel Functions, and Netlify Functions provide this capability. They are billed based on execution time, making them cost-efficient. Common use cases include form handling, API proxies, and scheduled tasks. Security is managed by the platform, reducing operational overhead. However, cold starts and vendor lock-in are challenges to consider. Serverless is ideal for modern applications that need scalability and efficiency without the burden of infrastructure management.",
    image: "https://picsum.photos/400/250?random=17",
    date: "2025-08-28",
    author: "Admin",
  },
  {
    id: 18,
    title: "Improving Web Accessibility",
    slug: "improving-web-accessibility",
    excerpt: "Make your apps inclusive for all users.",
    content:
      "Accessibility ensures that digital experiences are usable by everyone, including people with disabilities. Best practices include providing alt text for images, ensuring sufficient color contrast, supporting keyboard navigation, and using semantic HTML. Screen readers rely on proper markup to convey information, so headings and ARIA attributes matter. Testing accessibility with tools like Lighthouse or axe helps identify issues early. Beyond compliance, accessibility improves overall user experience and reach. Many countries also have legal requirements for accessible digital services. By prioritizing accessibility, developers build more inclusive and socially responsible applications that benefit all users.",
    image: "https://picsum.photos/400/250?random=18",
    date: "2025-08-29",
    author: "Admin",
  },
  {
    id: 19,
    title: "Caching Strategies for Web Apps",
    slug: "caching-strategies-for-web-apps",
    excerpt: "Enhance performance with effective caching strategies.",
    content:
      "Caching helps reduce load times and server costs by storing frequently accessed data closer to the user. Common caching strategies include browser caching, CDN caching, and application-level caching. For example, storing API responses in localStorage can reduce unnecessary requests. Service workers enable advanced caching patterns like stale-while-revalidate, providing instant loads with background updates. At the backend level, using Redis or Memcached improves database-heavy workloads. However, improper caching can lead to stale or inconsistent data, so strategies should match application needs. Well-implemented caching is one of the most effective ways to boost web performance and scalability.",
    image: "https://picsum.photos/400/250?random=19",
    date: "2025-08-30",
    author: "Admin",
  },
  {
    id: 20,
    title: "Unit Testing in React with Jest",
    slug: "unit-testing-in-react-with-jest",
    excerpt: "Write reliable React tests using Jest and React Testing Library.",
    content:
      "Unit testing ensures that individual components of your application work as expected. Jest, along with React Testing Library, provides a powerful setup for testing React applications. With Jest’s assertions and mocking capabilities, you can verify component behavior, handle async functions, and isolate logic. React Testing Library emphasizes testing components from the user’s perspective, focusing on interactions rather than implementation details. A typical test renders a component, queries by role or text, fires user events, and asserts the resulting DOM updates. You can mock network requests with jest.fn or libraries like MSW, stub timers with jest.useFakeTimers, and test async flows using findBy* queries and waitFor. Keep tests small and deterministic, avoid brittle snapshots of large trees, and prefer accessible queries to mirror real usage. Add coverage thresholds and a pre-commit script so regressions are caught early. With a fast feedback loop, teams refactor confidently, reduce bugs, and ship features faster.",
    image: "https://picsum.photos/400/250?random=20",
    date: "2025-08-31",
    author: "Admin",
  },
];
